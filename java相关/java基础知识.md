

## java 基础知识


1.Java基本类型哪些，所占字节和范围

+ 整型
    + byte  1字节 -2^7~2^7-1
    + short 2字节 -2^15~2^15-1
    + int   4字节 -2^31~2^31-1
    + long  8字节 -2^63~2^63-1
+ 浮点型
    + float 4字节
    + double    8字节   
+ char类型
   + char   2字节 0~655535

+ bollean类型
    bollean 1字节 false/true


2.Set、List、Map的区别和联系

+ Set 
    + 无重复对象 
    + Set接口继承Collection接口
    
    + HashSet
        + 无序
    
    + TreeSet
        + 有序
        + 访问任意元素，TreeSet最快
    
    + LinkedHashSet 
        + 有序
        + 访问任意元素，LinkedHashSet最慢
        + 移动元素或者替换比较快


+ List
    
    + List接口继承Collection接口
    + 特定次序存储元素
    + 涉及 "栈","队列","链表" 优先使用list
    
    + ArrayList
        + 允许对元素进行快速随机访问
        + 插入与移除元素的速度很慢
        + 查找速度快(优先使用 **for(int i = 0; i < list.size(); i++)** 这样的for循环 )
        + ArrayList实现不是同步的
        + 底层使用数组
        
    + LinkedList 
        + 链表结构 
        + 插入与删除速度快。
        + 随机访问则相对较慢
        + LinkedList实现不是同步的

    + Vector
        + 可增长的对象数组 (看作队列)
        + 可随机读取
        + Vector是线程安全的
        
    
    + Stack
        + 继承于Vector


+ Map

    + HashMap 
        + key,value 可以为null
        + 非同步
        + 
    + HashTable
        + 多线程安全
        + key,value 不可以为null
    + LinkedHashMap
    
    + TreeMap
    
    + WeakHashMap



3. 哪些集合类是线程安全的
+ ArrayList线程不安全，Vector线程安全；
+ HashMap线程不安全，HashTable线程安全；
+ StringBuilder线程不安全，StringBuffer线程安全。


4.为什么Set、List、map不实现Cloneable和Serializable接口
+ 克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。


5. Concurrenthashmap的实现，1.7和1.8的实现
6. Arrays.sort的实现
7. volatile的使用
8. 什么时候使用CopyOnArrayList
9. synchronied的使用
10. reentrantlock的实现和Synchronied的区别

11. CAS的实现原理以及问题
+ CAS:Compare and Swap(比较并交换)
+ 乐观锁的一种实现
+ CAS有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做并返回false。
+ CAS存在一个很明显的问题，即ABA问题。
12. AQS的实现原理
+ AbstractQueuedSynchronizer 队列同步器
+ 

13. 接口和抽象类的区别，什么时候使用

| 参数 | 抽象类 | 接口 |
| :------: | :------: | :------: |
| 默认的方法实现 | 它可以有默认的方法实现 | 接口完全是抽象的。它根本不存在方法的实现 |
| 实现 | 子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。 | 子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现 |
| 构造器 | 抽象类可以有构造器|    接口不能有构造器 |
| 与正常Java类的区别 |  除了你不能实例化抽象类之外，它和普通Java类没有任何区别   | 接口是完全不同的类型 | 
| 访问修饰符  |  抽象方法可以有public、protected和default这些修饰符  |   接口方法默认修饰符是public。你不可以使用其它修饰符。 |
| main方法 |  抽象方法可以有main方法并且我们可以运行它  | 接口没有main方法，因此我们不能运行它。|
| 多继承 | 抽象方法可以继承一个类和实现多个接口  | 接口只可以继承一个或多个其它接口 |
| 速度 | 它比接口速度要快  | 接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。| 
| 添加新方法 |   如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 | 如果你往接口中添加方法，那么你必须改变实现该接口的类。|

+ 如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。
+ 如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。
+ 如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。

14. 类加载机制的步骤，每一步做了什么，static和final修改的成员变量的加载时机

+ 类加载: 指的是 JVM 将类的 .class 文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个这个类的 java.lang.Class对象，用来封装类在方法区类的对象，加载的最终目标是堆中的 Class 对象

+ 类的初始化： 当程序使用某个类时，如果该类还没被初始化，加载到内存中，则系统会通过加载、连接（验证、准备、解析三个部分统称链接）、初始化三个过程来对该类进行初始化

+ 类加载步骤 ：加载----验证----准备----解析-----初始化

1. 加载

    + 通过一个类的全限定名来获取定义此类的二进制字节流。
    + 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
    + 在java堆中生成一个代表这个类的Class对象，作为访问方法区中这些数据的入口。

2. 验证

    + 确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全
    + 文件格式验证
    + 元数据验证
    + 字节码验证
    + 符号引用验证

3. 准备

    + 为类的静态变量分配内存。并将其初始化默认值
    + 实例变量在这个阶段不分配内存(实例变量会在对象实例化的时候分配在堆中)
    + 这个阶段设置的初始值是数据类型默认值（如0、0L、null、false等）
    + 例如：value在这个阶段值为0。(在初始化阶段 value=3)
    ```
    pulic staic  int value=4;
    ```

4. 解析
    + 解析阶段是虚拟机将常量池的符号引用替换成直接引用的过程。
    + 类和接口的解析
    + 字段解析
    + 类方法解析
    + 接口方法解析

5. 初始化
    真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源。
    初始化阶段是执行类构造器<clinit>()方法的过程。

15. 双亲委派模型

    自定义类加载器 -> 应用程序类加载器 -> 扩展类加载器 -> 启动类加载器
    + 工作流程：
        如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类
    + 优点：
        无论是哪个类加载器要加载一个类，最终都会委派给启动类加载器进行加载，这边保证了这个类在程序中的各种类加载器中都是同一个类。

16. 反射机制：反射动态擦除泛型、反射动态调用方法等
**反射机制**
+ 反射机制：程序运行状态中，对于任何一个类，都能知道这个类的所有属性和方法。对于任何一个对象，都能调用该对象的属性和方法
17. 动态绑定：父类引用指向子类对象

18. JVM内存管理机制：有哪些区域，每个区域做了什么

19. JVM垃圾回收机制：垃圾回收算法 垃圾回收器 垃圾回收策略

20. java中bio nio aio的区别和联系
+ bio ：同步阻塞
+ nio : 同步非阻塞
+ aio ：异步
+ 

21. 什么情况索引不会命中，会造成全表扫描
+ 左模糊查询　‘%...’无法直接使用索引
+ "!=" 查询
+ 索引列有函数或者计算："a+10=30"
+ 字符串与数字比较不使用索引
+ 
jvm参数的设置和jvm调优

什么情况产生年轻代内存溢出、什么情况产生年老代内存溢出

内部类：静态内部类和匿名内部类的使用和区别

Redis和memcached：什么时候选择redis，什么时候选择memcached，内存模型和存储策略是什么样的
 + redis 
    + 单线程(性能受限于CPU性能)
    + 多种数据结构(string(字符串),list(双向链表),dict(hash表),set(集合),zset(排序set))
    + 持久化
    + 支持简单的事务
+ memcache
    + 多线程,memcached可以利用多核优势
    + 简单的key-value数据结构
    + 不能持久化，数据不能备份
    + 并发场景下，用cas保证一致性
MySQL的基本操作 主从数据库一致性维护

mysql的优化策略有哪些

mysql索引的实现 B+树的实现原理

什么情况索引不会命中，会造成全表扫描

java中bio nio aio的区别和联系

为什么bio是阻塞的 nio是非阻塞的 nio是模型是什么样的

Java io的整体架构和使用的设计模式

Reactor模型和Proactor模型

http请求报文结构和内容

http三次握手和四次挥手

rpc相关：如何设计一个rpc框架，从io模型 传输协议 序列化方式综合考虑

Linux命令 统计，排序，前几问题等

StringBuff 和StringBuilder的实现，底层实现是通过byte数据，外加数组的拷贝来实现的

cas操作的使用

内存缓存和数据库的一致性同步实现

微服务的优缺点

线程池的参数问题

ip问题 如何判断ip是否在多个ip段中

判断数组两个中任意两个数之和是否为给定的值

乐观锁和悲观锁的实现

synchronized实现原理



消息队列广播模式和发布/订阅模式的区别

生产者消费者代码实现

死锁代码实现

线程池：参数，每个参数的作用，几种不同线程池的比较，阻塞队列的使用，拒绝策略

Future和ListenableFuture 异步回调相关
